import openai 
from openai import OpenAI
import json
import os
import re
from time import sleep
from vector_database import query_qdrant
from dotenv import load_dotenv

load_dotenv()

openai.api_key = "API-KEY" #env

def generate_skill_tree_from_documents(documents: list, max_chars: int = 18000) -> dict:
    combined = ""
    for i, doc in enumerate(documents):
        entry = f"{i+1}. Quelle: {doc.get('source', 'unbekannt')}\n{doc['text'].strip()}\n\n"
        if len(combined) + len(entry) > max_chars:
            break
        combined += entry
    
    if not combined.strip():
     print("ğŸš« Kein Text fÃ¼r Skill-Tree verfÃ¼gbar.")
     return {}

    docs_text = combined
    prompt = f"""
Du bist ein strukturierter Lernexperte fÃ¼r Softwareentwicklung.

Deine Aufgabe:
Aus den folgenden internen DokumentenauszÃ¼gen sollst du einen **prÃ¤zisen Skill-Tree** im JSON-Format erzeugen. Der Skill-Tree dient dazu, den Lernstand von Entwicklern gezielt zu erfassen.

ğŸ“Œ Ziel:
Der Skill-Tree soll als Grundlage fÃ¼r gezielte Wissensdiagnose und individuelle Empfehlungen dienen.

ğŸ”§ Anforderungen an die Struktur:
- Oberknoten: thematische Bereiche (z.â€¯B. â€SAP BTPâ€œ, â€CAPâ€œ, â€Fioriâ€œ, â€CDSâ€œ, â€Systemarchitekturâ€œ)
- Unterknoten: konkret benennbare, **prÃ¼fbare FÃ¤higkeiten** oder technische Konzepte
- Jeder Skill soll als **eigenstÃ¤ndige, bewertbare Einheit** formuliert sein
- Vermeide doppelte oder Ã¼berlappende Formulierungen
- Jeder Unterknoten enthÃ¤lt ein Feld "Quelle"

ğŸ“˜ Basisdaten (DokumentenauszÃ¼ge):
<<<
{docs_text}
>>>

Gib **nur den JSON-Skill-Tree** zurÃ¼ck â€“ ohne weitere ErklÃ¤rungen oder Einleitungen.
"""
    print("Prompt an LLM")
    print(prompt)

    response = openai.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "Du bist ein strukturierter KI-Assistent fÃ¼r Lernpfade."},
            {"role": "user", "content": prompt}
        ],
        temperature=0,
        max_tokens=1000,
    )

    content = response.choices[0].message.content
    cleaned = re.sub(r"^```(?:json)?|```$", "", content.strip(), flags=re.MULTILINE)

    try:
        skill_tree = json.loads(cleaned)
        return skill_tree
    except json.JSONDecodeError as e:
        print("âš ï¸ JSON-Fehler:", e)
        print("Rohdaten:\n", cleaned)
        return {}

def save_skill_tree_to_file(skill_tree: dict, filename="skill_tree_auto3.json"):
    try:
        os.makedirs("skill_trees", exist_ok=True)
        filepath = os.path.join("skill_trees", filename)
        with open(filepath, "w", encoding="utf-8") as f:
            json.dump(skill_tree, f, indent=2, ensure_ascii=False)
        print(f"âœ… Skill-Tree erfolgreich gespeichert unter: {filepath}")
    except Exception as e:
        print(f"âŒ Fehler beim Speichern des Skill-Trees: {e}")

def flatten(tree: dict) -> list:
    skills = []

    def recurse(t, prefix=""):
        for k, v in t.items():
            if isinstance(v, dict):
                # âœ… UnterstÃ¼tzt Struktur: {"skills": [{"name": ..., "source": ...}]}
                if "skills" in v and isinstance(v["skills"], list):
                    for skill in v["skills"]:
                        if isinstance(skill, dict) and "name" in skill:
                            skill_path = f"{prefix}{skill['name']}" if prefix else skill["name"]
                            quelle = skill.get("source", "unbekannt")
                            skills.append({"skill": skill_path, "quelle": quelle})
                else:
                    recurse(v, prefix=f"{k} > ")

    recurse(tree)
    return skills


def select_top_n_chunks_by_similarity_from_qdrant(skill_text: str, top_n=3):
    # semantische Suche direkt in Qdrant
    return query_qdrant(skill_text, limit=top_n)

def generate_15_questions_from_skill_tree(skill_tree_path, output_path="15_selektierte_fragen_LLM.json"):
    """
    Erstellt genau 5 technische Multiple-Choice-Fragen basierend auf dem gesamten Skill-Tree
    und den relevantesten Dokumenten aus der Vektordatenbank.
    """
    print("Starte die Generierung von 5 technischen Fragen...")

    # 1. Lade den Skill-Tree und extrahiere alle Skills als Text
    try:
        with open(skill_tree_path, "r", encoding="utf-8") as f:
            skill_tree = json.load(f)
    except FileNotFoundError:
        print(f"âŒ Fehler: Skill-Tree-Datei nicht gefunden unter {skill_tree_path}")
        return

    skill_list = flatten(skill_tree)
    if not skill_list:
        print("âŒ Keine Skills im Skill-Tree gefunden. Abbruch.")
        return

    # Kombiniere alle Skills zu einer einzigen Suchanfrage, um den besten Kontext zu finden
    all_skills_query = " ".join([s["skill"] for s in skill_list])
    skill_names_for_prompt = ", ".join([s["skill"] for s in skill_list])

    # 2. Hole die 7 relevantesten Dokumenten-Chunks fÃ¼r den gesamten Skill-Kontext
    print("Suche relevante Dokumente in der Vektordatenbank...")
    relevant_docs = select_top_n_chunks_by_similarity_from_qdrant(all_skills_query, top_n=7)

    if not relevant_docs:
        print("âš ï¸ Keine relevanten Dokumente fÃ¼r die Fragenerstellung gefunden.")
        return

    context_text_for_prompt = "\n\n---\n\n".join(
        [f"Dokument-Quelle: {doc.get('quelle', 'unbekannt')}\nInhalt: {doc['text']}" for doc in relevant_docs]
    )

    # 3. Erstelle einen einzigen, mÃ¤chtigen Prompt, der genau 5 Fragen anfordert
    prompt = f"""
  Du bist ein Fachexperte und technischer Trainer fÃ¼r SAP-Systemarchitektur und -Entwicklung.
  Deine Aufgabe ist es, ein anspruchsvolles Quiz zu erstellen, um das Wissen von Entwicklern zu Ã¼berprÃ¼fen.

  Basierend auf den folgenden Skills und den dazugehÃ¶rigen DokumentenauszÃ¼gen, erstelle GENAU 5 unterschiedliche, technische Multiple-Choice-Fragen.

  ---
  **VERFÃœGBARE SKILLS:**
  {skill_names_for_prompt}

  ---
  **RELEVANTE DOKUMENTENAUSZÃœGE ALS KONTEXT:**
  {context_text_for_prompt}

  ---
  **ANWEISUNGEN FÃœR DIE AUSGABE:**
  1.  **Anzahl:** Erstelle **exakt 5** Fragen. Nicht mehr, nicht weniger.
  2.  **QualitÃ¤t:** Die Fragen mÃ¼ssen technisch fundiert, prÃ¤zise und nicht trivial sein.
  3.  **Format:** Gib das Ergebnis als ein einziges JSON-Objekt zurÃ¼ck. Die SchlÃ¼ssel des Objekts sollen die Namen der Skills sein, auf die sich die jeweilige Frage bezieht.
  4.  **Inhalt:** Jede Frage muss eine korrekte Antwort (`"korrekt": true`) und mindestens zwei plausible, aber falsche Antworten (`"korrekt": false`) haben.
  5.  **Quelle:** Ãœbernimm die "Dokument-Quelle" aus dem Kontext als Wert fÃ¼r das "quelle"-Feld im JSON.

 **BEISPIEL-FORMAT DER JSON-AUSGABE:**
  ```json
 {{
  "Name des ersten Skills": {{
    "frage": "Technische Frage zu Skill 1...",
    "antworten": [
      {{ "text": "Korrekte Antwort", "korrekt": true }},
      {{ "text": "Falsche Antwort 1", "korrekt": false }},
      {{ "text": "Falsche Antwort 2", "korrekt": false }}
    ],
    "quelle": "Name der Dokument-Quelle"
  }},
  "Name des zweiten Skills": {{
    "frage": "Technische Frage zu Skill 2...",
    "antworten": [
      {{ "text": "...", "korrekt": true }},
      {{ "text": "...", "korrekt": false }}
    ],
    "quelle": "..."
  }},
  "...": "..."
 }}
 """
    print("Sende Anfrage an das LLM, um 5 Fragen zu generieren...")

    client = OpenAI(api_key='API-KEY') #env
    response = client.chat.completions.create(
        model="gpt-4o", 
        messages=[
            {"role": "system", "content": "Du bist ein Experte fÃ¼r technische Wissensabfragen im JSON-Format."},
            {"role": "user", "content": prompt}
        ],
        temperature=0.3,
        response_format={"type": "json_object"} # Erzwingt JSON-Ausgabe
      )
    content = response.choices[0].message.content
    questions_json = json.loads(content)

     # 5. Speichere das Ergebnis
    with open(output_path, "w", encoding="utf-8") as f:
        json.dump(questions_json, f, indent=2, ensure_ascii=False)

    print(f"âœ… {len(questions_json)} Fragen erfolgreich in {output_path} gespeichert.")

def generate_feedback_report(answer_data: list) -> str:
    prompt = f"""
Du bist ein Lerntutor. Analysiere die folgenden Quiz-Antworten und gib dem Nutzer eine freundliche, aber konkrete RÃ¼ckmeldung zu seinem Wissen.

Empfiehl, welche Quellen er sich nochmal anschauen sollte und warum. BegrÃ¼nde das pÃ¤dagogisch.

Ziel ist es, das Wissen im Bereich SAP Clean Core, CDS-Views und verwandten Themen zu verbessern.

### Antwortdaten:
{json.dumps(answer_data, indent=2, ensure_ascii=False)}
"""
    client = OpenAI()  # oder dein bestehendes Konstrukt
    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "Du bist ein hilfsbereiter Lerntutor."},
            {"role": "user", "content": prompt}
        ],
        temperature=0.7,
        max_tokens=600
    )
    return response.choices[0].message.content.strip()
